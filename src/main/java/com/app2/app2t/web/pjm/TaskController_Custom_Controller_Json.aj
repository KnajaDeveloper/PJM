// WARNING: DO NOT EDIT THIS FILE. THIS FILE IS MANAGED BY SPRING ROO.
// You may push code into the target .java compilation unit if you wish to edit any member(s).

package com.app2.app2t.web.pjm;

import com.app2.app2t.domain.pjm.*;
import com.app2.app2t.util.ApplicationConstant;
import com.app2.app2t.util.AuthorizeUtil;
import flexjson.JSONSerializer;

import org.json.JSONArray;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.web.multipart.MultipartHttpServletRequest;
import org.apache.commons.io.IOUtils;

import javax.activation.MimetypesFileTypeMap;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletResponse;
import java.util.*;
import java.net.*;
import java.io.*;

privileged aspect TaskController_Custom_Controller_Json {

    @RequestMapping(value = "/findProjectByTask", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.findProjectByTask(
            @RequestParam(value = "typeTask", required = false) long typeTask
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Task> result = Task.findProjectByTask(typeTask);
            return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(result), headers, HttpStatus.OK);
        } catch (Exception e) {
            /*Logger.error(e.getMessage(), e);*/
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findPaggingData", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> TaskController.findPaggingData(
            @RequestParam(value = "id", required = false) Long id
            ,@RequestParam(value = "firstResult", required = false) Integer firstResult
            ,@RequestParam(value = "maxResult", required = false) Integer maxResult
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Map<String,Object>> resultSearch = new ArrayList<>();
            List<Task> taskes = Task.findTaskDataPagingData(id, firstResult, maxResult);
            for (Task task: taskes) {
                Map<String,Object> buffer = new HashMap<>();
                buffer.put("id", task.getId());
                buffer.put("taskCode", task.getTaskCode());
                buffer.put("taskName", task.getTaskName());
                buffer.put("taskCost", task.getTaskCost());
                buffer.put("typeTaskCode", task.getTypeTask().getTypeTaskCode());
                buffer.put("typeTaskName", task.getTypeTask().getTypeTaskName());
                buffer.put("empCode", task.getEmpCode());
                buffer.put("dateStart", task.getDateStart());
                buffer.put("dateEnd", task.getDateEnd());
                buffer.put("progress", task.getProgress());
                buffer.put("fileName", task.getFileName());
                buffer.put("detail", task.getDetail());
                buffer.put("inUse", Plan.findPlanByID(task.getId()));
                resultSearch.add(buffer);
            }
            return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(resultSearch), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error("findEvaPeriodTime :{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findPaggingSize", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> TaskController.findPaggingSize(
            @RequestParam(value = "id", required = false) Long id
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            Long size = Task.findTaskDataPagingSize(id);
            Map dataSendToFront = new HashMap();
            dataSendToFront.put("size",size);
            return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(dataSendToFront), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error("findEvaPeriodTime :{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/saveTask/{taskCode}/{taskName}/{taskCost}/{typeTask}/{empCode}/{dateStart}/{dateEnd}/{fileName}/{detail}/{progress}/{id}",method = RequestMethod.POST, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.saveTask(
            @PathVariable("taskCode") String taskCode,
            @PathVariable("taskName") String taskName,
            @PathVariable("taskCost") Double taskCost,
            @PathVariable("typeTask") String typeTask,
            @PathVariable("empCode") String empCode,
            @PathVariable("dateStart") String dateStart,
            @PathVariable("dateEnd") String dateEnd,
            @PathVariable("fileName") String fileName,
            @PathVariable("detail") String detail,
            @PathVariable("progress") Integer progress,
            @PathVariable("id") Long id,
            MultipartHttpServletRequest multipartHttpServletRequest
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            if(!fileName.equals("null")){
                Task.uploadFileAndInsertDataFile(id, taskCode, multipartHttpServletRequest);
            }

            List<TypeTask> tt = TypeTask.findTypeTaskByTypeTaskCode(typeTask);
            List<Program> pg = Program.findProgramByID(id);
            Task task = Task.saveTask(taskCode, taskName, taskCost, tt.get(0), empCode,
                    dateStart, dateEnd, fileName, detail, progress, pg.get(0));
            return new ResponseEntity<String>(headers, HttpStatus.CREATED);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findEditTask/{id}/{taskCode}/{taskName}/{taskCost}/{typeTask}/{empCode}/{dateStart}/{dateEnd}/{fileName}/{detail}/{progress}/{programID}",method = RequestMethod.POST, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.findEditTask(
            @PathVariable("id") Long id,
            @PathVariable("taskCode") String taskCode,
            @PathVariable("taskName") String taskName,
            @PathVariable("taskCost") Double taskCost,
            @PathVariable("typeTask") String typeTask,
            @PathVariable("empCode") String empCode,
            @PathVariable("dateStart") String dateStart,
            @PathVariable("dateEnd") String dateEnd,
            @PathVariable("fileName") String fileName,
            @PathVariable("detail") String detail,
            @PathVariable("progress") Integer progress,
            @PathVariable("programID") Long programID,
            MultipartHttpServletRequest multipartHttpServletRequest
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            if(!fileName.equals("null")){
                Task.uploadFileAndInsertDataFile(programID, taskCode, multipartHttpServletRequest);
            }
            List<TypeTask> tt = TypeTask.findTypeTaskByTypeTaskCode(typeTask);
            List<Task> result = Task.findEditTask(id, taskCode, taskName, taskCost, tt.get(0), empCode,
                    dateStart, dateEnd, fileName, detail, progress);
            return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(result), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findDeleteTask",method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.findDeleteTask(
            @RequestParam(value = "id", required = false) Long id,
            @RequestParam(value = "taskID", required = false) Long taskID,
            @RequestParam(value = "taskCode", required = false) String taskCode
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Task> result = Task.findDeleteTask(id, taskID, taskCode);
            return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(result), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findSizeTaskByTaskCode",method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.findSizeTaskByTaskCode(
            @RequestParam(value = "id", required = false) long id,
            @RequestParam(value = "taskCode", required = false) String taskCode
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Task> result = Task.findSizeTaskByTaskCode(id, taskCode);
            return  new ResponseEntity<String>(result.size() + "", headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findCheckProgramCode",method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.findCheckProgramCode(
            @RequestParam(value = "program", required = false) String program
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Program> pg = Program.findProgramByProgramCode(program);
            List<Task> result = Task.findCheckProgramCode(pg.get(0));
            return  new ResponseEntity<String>(result.size() + "", headers, HttpStatus.OK);

        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findTaskCostforSum", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> TaskController.findTaskCostforSum(
            @RequestParam(value = "id", required = false) Long id
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List resultSearch = Task.findTaskCostforSum(id);
            return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(resultSearch), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error("findEvaPeriodTime :{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findTaskProgestByProgram",method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.findTaskProgestByProgram(
            @RequestParam(value = "program", required = false) String program
    ){
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Program> mo = Program.findProgramByProgramCode(program);
            List<Task> result = Task.findTaskProgestByProgram(mo.get(0));
            //LOGGER.info(">>>>>>>>>>>>>>>>>>Modul"+project);           
            return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(result), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    @RequestMapping(value = "/findTaskProgressforAVG", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> TaskController.findTaskProgressforAVG(
            @RequestParam(value = "id", required = false) Long id
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List resultSearch = Task.findTaskProgressforAVG(id);
            return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(resultSearch), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error("findEvaPeriodTime :{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findEmptyTask", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> TaskController.findEmptyTask() {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            Map<String,Object> result = new HashMap<>();
            List<Task> tasks = Task.findEmptyTask();
            List<OtherTask> otherTasks = OtherTask.findEmptyOtherTask();
            result.put("Task",tasks);
            result.put("OtherTask",otherTasks);
            return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(result), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error("findEvaPeriodTime :{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/downloadFile/{programID}/{taskCode}/{fileName}", method = RequestMethod.GET)
    public ResponseEntity<String> TaskController.downloadFile(
            @PathVariable("programID") String programID,
            @PathVariable("taskCode") String taskCode,
            @PathVariable("fileName") String fileName,
            HttpServletResponse response
    ) throws ServletException, IOException {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        InputStream in = null;
        try {
            String mimeType = new MimetypesFileTypeMap().getContentType(fileName);
            String fileName1 = URLEncoder.encode(fileName, "UTF-8");
            String fileName2 = URLDecoder.decode(fileName1, "ISO8859_1");
            response.setContentType(mimeType);
            response.addHeader("Content-Disposition", "attachment; filename=\""+fileName2+"\"");
            String pathFile = ApplicationConstant.PATH_PJM_FILE + programID + "/" + taskCode + "/";
            in = new FileInputStream(pathFile + fileName);
            IOUtils.copy(in, response.getOutputStream());
            return new ResponseEntity<String>(headers, HttpStatus.OK);
        } catch (Exception e) {
            e.printStackTrace();
            LOGGER.error("findEvaPeriodTime :{}", e);
            return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }finally{
            IOUtils.closeQuietly(in);
        }
    }

    @RequestMapping(value = "/selectTaskFollowTofirstPage",method = RequestMethod.GET, headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.selectTaskFollowTofirstPage(
            @RequestParam(value = "maxResult", required = false) Integer maxResult,
            @RequestParam(value = "firstResult", required = false) Integer firstResult
    )
            {
                HttpHeaders headers = new HttpHeaders();
                headers.add("Content-Type", "application/json;charset=UTF-8");

                try
                {
                    List<Map<String,Object>> resultSearch = new ArrayList<>();
                    String userName = AuthorizeUtil.getUserName();
                    Map employee = emRestService.getEmployeeByUserName(userName);
                    List<FollowerTask> result = FollowerTask.selectTaskFollowTofirstPage(employee.get("empCode").toString(),maxResult,firstResult);
                    for(FollowerTask followerTask : result) {
                        Map<String, Object> map = new HashMap<>();

                        map.put("taskCode", followerTask.getTask().getTaskCode());
                        map.put("id", followerTask.getTask().getId());
                        map.put("taskName", followerTask.getTask().getTaskName());
                        map.put("managerEmpCode", followerTask.getTask().getEmpCode());
                        map.put("followEmpCode", followerTask.getEmpCode());
                        map.put("progress", followerTask.getTask().getProgress());
                        map.put("program", Program.findProgram(followerTask.getTask().getId()));
                        map.put("module", ModuleProject.findModuleProject(Program.findProgram(followerTask.getTask().getId()).getModuleProject().getId()));
                        map.put("project", Project.findProject(Program.findProgram(followerTask.getTask().getId()).getModuleProject().getProject().getId()));
                        resultSearch.add(map);

                    }
                    return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(resultSearch), headers, HttpStatus.OK);
                } catch (Exception e) {
                    LOGGER.error(e.getMessage(), e);
                    return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
                }
            }

    @RequestMapping(value = "/taskPaggingSizeTaskFollow", method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    @ResponseBody
    public ResponseEntity<String> TaskController.taskPaggingSizeTaskFollow(
    )
            {
                HttpHeaders headers = new HttpHeaders();
                headers.add("Content-Type", "application/json;charset=UTF-8");
                try
                {
                    String userName = AuthorizeUtil.getUserName();
                    Map employee = emRestService.getEmployeeByUserName(userName);
                    Long result = FollowerTask.taskFollowPaggingSizeTask(employee.get("empCode").toString());
                    Map dataSendToFront = new HashMap();
                    dataSendToFront.put("size",result);
                    return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(dataSendToFront), headers, HttpStatus.OK);
                } catch (Exception e) {
                    LOGGER.error("findEvaPeriodTime :{}", e);
                    return new ResponseEntity<String>("{\"ERROR\":" + e.getMessage() + "\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
                }
            }

    @RequestMapping(value = "/editTaskStatus",method = RequestMethod.GET, produces = "text/html", headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.editTaskStatus(
            @RequestParam(value = "taskId", required = false) Long taskId
            ,@RequestParam(value = "status", required = false) String status
    ) {
        HttpHeaders headers = new HttpHeaders();
        headers.add("Content-Type", "application/json;charset=UTF-8");
        try {
            List<Task> result = Task.updateStatusTask(taskId, status);
            return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(result), headers, HttpStatus.OK);
        } catch (Exception e) {
            LOGGER.error(e.getMessage(), e);
            return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @RequestMapping(value = "/findTaskByProjectIdOrModuleIdOrTypeTaskIdOrTaskStatus",method = RequestMethod.GET, headers = "Accept=application/json")
    public ResponseEntity<String> TaskController.selectTaskFollower(
            @RequestParam(value = "maxResult", required = false) Integer maxResult,
            @RequestParam(value = "firstResult", required = false) Integer firstResult,
            @RequestParam(value = "option", required = false) String option,
            @RequestParam(value = "projectId", required = false) String projectId,
            @RequestParam(value = "moduleId", required = false) String moduleId,
            @RequestParam(value = "typeTaskId", required = false) String typeTaskId,
            @RequestParam(value = "statusTask", required = false) String statusTask,
            @RequestParam(value = "empCode", required = false) String empCode

    )
        {
            HttpHeaders headers = new HttpHeaders();
            headers.add("Content-Type", "application/json;charset=UTF-8");

            try{
                List<Map<String,Object>> resultSearch = new ArrayList<>();
                if(empCode.equals("")) {
                    List<Task> taskList = Task.findTaskByProjectIdOrModuleIdOrTypeTaskIdOrTaskStatus(
                            maxResult,firstResult,projectId,moduleId,typeTaskId,statusTask,option);
                    if(!option.toLowerCase().equals("size")) {
                        for(Task task : taskList) {
                            Map<String, Object> map = new HashMap<>();
                            map.put("taskCode", task.getTaskCode());
                            map.put("id", task.getId());
                            map.put("taskName", task.getTaskName());
                            map.put("progress", task.getProgress());
                            map.put("program", task.getProgram().getProgramName());
                            map.put("module", task.getProgram().getModuleProject().getModuleName());
                            List<ModuleManager> listMM = ModuleManager.findModuleManagerByModuleProject(ModuleProject.findModuleProject(task.getProgram().getModuleProject().getId()));
                            map.put("moduleManager" ,listMM);
                            map.put("project", task.getProgram().getModuleProject().getProject().getProjectName());
                            map.put("follower","");
                            resultSearch.add(map);
                        }
                        return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(resultSearch), headers, HttpStatus.OK);
                    }
                    else {
                        Map dataSendToFront = new HashMap();
                        dataSendToFront.put("size",taskList.size());
                        return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(dataSendToFront), headers, HttpStatus.OK);
                    }
                }
                else{
                    List<FollowerTask> taskList = FollowerTask.findFollowerTaskByProjectIdOrModuleIdOrTypeTaskIdOrTaskStatus(
                            maxResult,firstResult,projectId,moduleId,typeTaskId,statusTask,option,empCode);
                    if(!option.toLowerCase().equals("size")) {
                        for(FollowerTask task : taskList) {
                            Map<String, Object> map = new HashMap<>();
                            map.put("taskCode", task.getTask().getTaskCode());
                            map.put("id", task.getTask().getId());
                            map.put("taskName", task.getTask().getTaskName());
                            map.put("progress", task.getTask().getProgress());
                            map.put("program", task.getTask().getProgram().getProgramName());
                            map.put("module", task.getTask().getProgram().getModuleProject().getModuleName());
                            List<ModuleManager> listMM = ModuleManager.findModuleManagerByModuleProject(ModuleProject.findModuleProject(task.getTask().getProgram().getModuleProject().getId()));
                            map.put("moduleManager" ,listMM);
                            map.put("project", task.getTask().getProgram().getModuleProject().getProject().getProjectName());
                            map.put("follower",task.getEmpCode());
                            resultSearch.add(map);
                        }
                        return  new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(resultSearch), headers, HttpStatus.OK);
                    }
                    else {
                        Map dataSendToFront = new HashMap();
                        dataSendToFront.put("size",taskList.size());
                        return new ResponseEntity<String>(new JSONSerializer().exclude("*.class").deepSerialize(dataSendToFront), headers, HttpStatus.OK);
                    }
                }
            } catch (Exception e) {
                LOGGER.error(e.getMessage(), e);
                return new ResponseEntity<String>("{\"ERROR\":"+e.getMessage()+"\"}", headers, HttpStatus.INTERNAL_SERVER_ERROR);
            }
        }
}
